# Упражнение 3 - Redux.

За основу этого упражнения мы возьмем приложение покупательская корзина из
предыдущего курса - React 1. В этом приложении как и во многих других
приложениях на React в первый раз возникла проблема с тем, а как один компонент
может делиться своим состояниям с соседними компонентами. В частности в нашем
приложении был компонента `Counter` который позволял увеличивать количество
товаров в корзине. В тоже время для подсчета итого количества товаров в корзине
в нашем компоненте `Basket` нам нужно было знать какое количество товаров указал
пользователь. Как вы можете помнить мы решили эту проблему поднятием состояния
до родительского компонента и пробросом свойств компонентов в компоненты
потомки. Такой подходит подходит для простых приложений, но в сложных
приложениях с большим количеством компонентов быстро начинают возникать
сложности:

- Как понять какие компоненты изменяют состояния, а какие просто пробрасывают
  свойства в потомки?
- Какие возможно изменения состояний и где, особенно в случаях когда мы передаем
  в компонент функцию напрямую обновления состояния `setItems` которая может
  быть вызвана любым способом.
- Как тестировать эти изменения без поднимания всего дерева компонентов каждый
  раз

В решении этих сложней нам поможет redux и мы его подключим к этому приложению.

## Задание

Начнем с его установки и также сразу подключим расширения redux для работы с
react.

```shell
npm install @reduxjs/toolkit
npm install react-redux
```

Для начала работы с Redux нам необходимо создать store(хранилище). Для его
создания мы используем метод `configureStore`

```js
// создайте новый файл src/store.js
import { configureStore } from "@reduxjs/toolkit";
import reducer from "./reducer";
export const setupStore = () => configureStore({ reducer: reducer });
const store = setupStore();
export default store;
```

Напишем простой тест для нашего хранилища:

```js
// создайте новый файл src/store.test.js
import { setupStore } from "./store";

let store;
beforeEach(() => {
  // before each test create a new store to avoid accidentally sharing state between tests
  store = setupStore();
});
it("содержит товары", () => {
  // функция getState позволяет нам получить текущее состояние хранилища
  const state = store.getState();

  // чтобы не сравнивать весь объект вы возмем только заголовки товаров
  const titles = state.items?.map((x) => x.title);

  // И сравним их с тем что мы ожидаем
  expect(titles).toEqual(["Товар1", "Товар2", "Товар3"]);
});
```

Для запуска тестов перейдите в папке с приложение и запустите команду
`npm run test`.

Если у вас выпала следующая ошибка:
`Cannot read properties of undefined (reading 'items')` при запуске тесты значит
мы на правильном пути. Что нам показывает эта ошибка, это то что наше хранилище
в данный момент не содержит никаких данных. Давайте исправим это! Для этого мы
можем воспользоваться альтернативным более низкоуровневым API в Redux -
`createReducer` - которой позволяет нам создать только reducer.

```js
// создайте новый файл src/reducer.js
import { createReducer } from "@reduxjs/toolkit";

const reducer = createReducer({ items: [] }, (builder) => builder);
export default reducer;
```

Теперь подключим его к нашему хранилищу:

```js
// store.js
import reducer from "./reducer";
const store = configureStore({ reducer: reducer });
```

Обратите внимание на терминал в котором еще запущен тест или перезапустите его.
Вы увидите новую ошибку:

```shell
    - Array [
    -   "Товар1",
    -   "Товар2",
    -   "Товар3",
    - ]
    + Array []
```

Эта ошибка говорит нам о том, что наше текущее состояние не содержит нужных
товаров. Используя товары из `items.json` попробуйте исправить эту ошибку
самостоятельно - вы можете скопировать данные из этого файла, их не нужно
импортировать в ваш проект.

Отлично! Надеюсь, что у вас все получилось и мы переходим к последней концепции
Redux - actions(действия).

Мы рассмотрим как создавать действия вручную, т.к. возможно вам придется
столкнуться с кодом в котором все еще есть большое количество действий созданных
вручную. Для создания действия нам нужно использовать метод `createAction` из
`redux-toolkit`.

```js
// в файле reducer.js
import { createAction } from "@reduxjs/toolkit";
// названия может быть любое - главное чтобы оно было уникально
export const addBasketItemCount = createAction("ADD_BASKET_ITEM_COUNT");
```

Прежде чем подключить action к нашему store через reducer мы создадим тест
который будет выводить нам ошибку:

```js
// добавить в store.test.js
import { addBasketItemCount } from "./reducer";
// ...
it("может добавить количество к товару", () => {
  // используем фиксированый ID из json файла
  const uid = "86ed58db-082d-45ab-aa81-5218059349cb";

  // метод dispatch позволяет сообщить хранилищу о том что нужно совершить заданное действие
  store.dispatch(addBasketItemCount({ uid: uid, qty: 1 }));
  const state = store.getState();

  // проверяем что количество изменилось на том элемента на котором мы добавили количество
  const item = state.items.find((x) => x.uid === uid);
  expect(item.qty).toEqual(2);
});
```

Если все получилось то тест будет выводить:

```
  Expected: 2
  Received: 1
```

И теперь нам нужно обработать это действие, для этого его нужно добавить в
`reducer` и написать логику обновления

```js
// reducer.js
// ..
(builder) =>
  builder.addCase(addBasketItemCount, (state, action) => {
    // в отличии от setItems мы можем напрямую обновлять состояние - спасибо `redux/toolkit`
    state.items.find((x) => x.uid === action.payload.uid).qty +=
      action.payload.qty;
  });
```

Теперь у нас есть работающее логика приложения - в которой мы может быть уверены
благодаря тестам.

## Подключение Redux к приложению.

Это происходит в файле `index.js` приложения.

```js
import store from "./store";
import { Provider } from "react-redux";
// заменить root.render
root.render(
  <Provider store={store}>
    <App />
  </Provider>,
);
```

В нашем приложении чтобы получить доступ к store мы будем использовать
`useSelector` hook - он позволяет нам получить доступ к части нашего store.

```jsx
// файл Basket.js
import { useSelector } from "react-redux";
//... заменим setItems на пустую функцию чтобы избежать ошибок
<BasketItem {...item} key={item.uid} items={items} setItems={() => {}} />;
```

А также закомментируем часть App.js

```jsx
// if (error) {
//   basketPlace = <div>Ошибка: {error.message}</div>;
// } else if (!isLoaded) {
//   basketPlace = <div>Загрузка...</div>;
// } else {
basketPlace = <Basket items={startItems} />;
// }
```

Мы пока оставим закомментированым код обработки ошибок и получения данных
асинхронно в `App.js` упрощения этого упражнения. В будущем мы вернемся к
вопросу того как получить данные асинхронно в redux.

И наконец в `Counter.js` мы можем подключить наш action с помощью хука
`useDispatch`.

```jsx
// Counter.js
import { useDispatch } from "react-redux";
import { addBasketItemCount } from "../reducer";
//...
const Counter = ({ value, uid, items, setItems }) => {
const dispatch = useDispatch();
// заменить функцию qtyButtonAdd
const qtyButtonAdd = () => {
    dispatch(addBasketItemCount({ uid, qty: 1 }));
  };
```

Откройте приложение и попробуйте добавить количество на любом из элементов
корзины.

## Доп. задания

### 1. Самостоятельно доделать действия и их обработку для уменьшения количества и установки количества в любое значение.

Попробуйте также написать тесты до того как сделаете обработчики действий

### 2. Убрать пробрасывание свойств которые больше не нужно когда мы используем Redux

Когда мы поднимали состояние вверх нам приходилось пробрасывать функции
изменения `setItems` состояния вниз до потомков. Поскольку в redux мы вместо
этого используем `useDispatch` их можно спокойно удалить.

## Файлы

- src/App.js
- src/components/Counter.js
- src/components/Basket.js
- src/index.js
