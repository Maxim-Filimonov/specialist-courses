# Упражнение 4 - Асинхронный Redux.

Асинхронность в Redux заслуживает отдельного упражнения. Если вы будете смотрите
на другие альтернативные модели управления состояния именно асинхронная
обработка это то где большинство из этих моделей отличаются сильно друг от
друга. Сначала мы можем разобраться в том, а что же такое асинхронная обработка
и в чем ее сложность. Асинхронная обработка того или иного действия - это
обработка которая выполняется с задержкой - часто эти задержки могут быть
связаны с необходимость вызова API чтобы передать данные на сервер, либо
запросить данные с него. `redux/toolkit` включает в себя специальный инструмент
который позволяет Redux обрабатывать и создавать такие действия в специальном
формате с помощью функции `createAsyncThunk`. Еслидля обычных действий у нас
есть только один обработчик, то для асинхронный действия нам часто нужно писать
3 обработчика:

- `pending` - обработка асинхронной части действия началась, но еще не
  закончилась обычно в этом случае показывают пользователю какой то индикатор
  загрузки
- `fulfilled` - обработка асинхронной части действия закончилась и данные пришли
  успешно
- `rejected` - обработка асинхронной части действия завершилась с ошибкой

В каждом из этих обработчиков мы можем описать что делать в случае той или иной
ситуации. Рассмотрим пример такого асинхроного действия из упражнения 2:

```js
export const incrementAsync = createAsyncThunk(
  "counter/fetchCount",
  async (amount) => {
    const response = await fetchCount(amount);
    // То что мы вернем здесь будет результатом выполнения асинхронного действия
    return response.data;
  },
);
```

Это асинхронная функция, которая ожидает когда `fetchCount` вернет результат и
затем вытаскивает из этого результата поле `data`.

Для обработки мы используем следующий код:

```js
// Поле extraReducers позволяет нам ссылаться на действия неопределенные напрямую в поле reducers. Такие как асинхронные действия которые пишутся как отдельные функции.
  extraReducers: (builder) => {
    builder
      .addCase(incrementAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.value += action.payload;
      });
  },
```

В этом примере мы обрабатываем только два состояния - `pending` и `fulfilled`.
Состояние ошибки в этом примере не выполняется, хотя при использовании в
реальных системах сильно рекомендуется незабывать его добавлять.

## Задание

Мы продолжим доработку корзины в этом упражнении. Ваше задание состоит в том,
чтобы вернуть загрузку данных о корзине с сервера. Пример этого кода есть в
`App.js`. При этом корректно обрабатывать все состояния. Вместо `useFetch`

## Доп. задания

## Файлы

- src/App.js
- src/components/Counter.js
- src/components/Basket.js
- src/index.js
